此文件是针对kaggle 的鲸鱼尾部识别比赛所建立的。

大致思路为：

	1.用normal.py 把所有所有需要训练图片规则化为72*72*3，因为有的是单通道（channel）图片所以使用了cv2模块的单通道转三通道模块，把单通道图片转化为三通道图片。

	2.使用positive_negative.py 产生正负样本对。正样本对就是id相同的鲸鱼，即同一条鲸鱼的图片配成的对，总共约8.5w对，目的是拉近相同鲸鱼图片之间高维空间对应的距离；负样本对即不同鲸鱼配成的对，目的是加大不相同鲸鱼之间高维空间对应的距离。对于负样本对的产生，刚开始的想法是产生跟正样本对相差不多的对数，这样平衡一些，在训练时能拉近相同对之间的距离，同时疏远不同鲸鱼图片对之间的距离。 训练到收敛之后，此时的样本对不再有太大作用，故增加负样本对，想法是：既然不能拉近相同鲸鱼图片的距离，就疏远一些不同鲸鱼图片之间的距离。事实证明还是有效，从炎之（这个名字好听，嘻嘻嘻...）的98.5的正确率，各种提高提高到了99.5。

	3.dataset.py是负责为train处理数据集的，刚开始把所有样本对的地址（path）读入内存，然后打乱顺序，留后2000个不训练作为测试的样本。每次读batch的时候，先从地址里面取batch_size个地址出来，再从硬盘中读取相应的图片，矩阵化之后除以了255.0（这个就是刚踩的一个坑）归一化，在送入train.py进行训练。

	4.model.py 我fork的作者说，这是一个简化版的VGG模型，不过提取特征效果是真的不错。

	5.train.py model 搭建好之后，把数据丢入训练，注意：训练必须用sess.run()语句才能训练。相当于前向传播和反向传播成型之后，用sess.run（）  里面变量填什么，这个网络就计算到哪一步。如后面的test_from_saved_model_entry.py里面sess.run([distance],feed_dic = ...)就只算到
了distance，就没有跑到后面的optimizer那里去，就没有训练模型，再走几步到optimizer才开始训练，而我们测试不用训练，所以不走到那一步
。

	6.test_pairs.py 是用于生成test文件夹里面图片和train文件夹里图片的配对的。让test里面的图片和train里面每一张图片配对，这样保证和每个图片都对比一次，但是特别费时间。后期看2.5w对能否全部加载入内存（如果内存允许），不一次一次读，读一次用一次太费时间了。测试的时候train没花太多时间，主要是花在读取文件上面了。

	7.test_from_saved_model_entry.py 是用于计算上方所生成的对比组的。------记住读入的图片矩阵化之后一定要除以255.0----否则对于神经网络来说这些图片就是不认识的（类似的都没见过，因为前面dataset读入的时候是处以了255.0的）。

	8.get_id.py 即为从test_from_saved_model_entry.py 保存的distance文件寻找distance排前五的，作为id。输出到example.csv。

	

以下需要注意：
	1.train.csv 是专门用excel排序过的，不是原本的csv文件

--2019.01.21更新
	去掉一些原本有的 但对这次比赛无用的文件

--2019.01.22更新
	修复一个惊天bug，测试的时候读入图片矩阵化后没有处以255.0

